# Introducción:
Pentesting mobile principalmente se basa en analisis de codigo estatico y dinamico de una APK para android e IPA para IOS.
    
# Framework base:
OWASP así como para web, tambien para mobile tiene su versión de testing guide, las cuales son muy amplias y son una base solida para un correcto proceso.
  - https://mas.owasp.org/#our-mission
  - https://owasp.org/www-project-mobile-top-10/2023-risks/

# Virtualizadores:
  - Genymotion: Virtualizador basado en virtualbox, con versión personal gratuita, pero con limitaciones como no permitir rootear.

# Estructura basica:

## Android APK:
Estructura de ficheros y carpetas de una aplicación:
- /META-INF:
  - Manifest: Creador, fechas, etc.
- /res: Ficheros que no se compilan.
  - /layout: Pantallas de la aplicación.
  - /drawable: Imagenes que se usan en la aplicación.
- resources.arsc: Codigo Complilado
- Classes.dex: Logica base de la aplicación
- AndriodManifest.xml: Lista de permisos y funciones de la aplicación.
- Classes.dex: Codigo fuente de la aplicación.

# Decompilación y lectura:
## Android:
  - Lectura legible:
    - apktool <nameapk>.apk
  - Decompilar:
    - unzip <nameapk>.apk
    - j2d-dex2jar classes.dex
    - Open with jd-gui file classes.jar

# Ataques comunes:
Lista de comandos para revisión de vulnerabilidades comunes en base a DIVA APK.

## Insecure Logging:
  - Siempre es buena opción ir guardando los Logs salientes de la aplicación mientras navegamos, porque podemos buscar datos sensibles que se esten guardando como Logs.
    - adb shell ps | grep <appname> (Conseguir el numero del proceso)
    - adb logcat | grep <processnumber> (Imprimira todo lo que este pasado por un proceso de log)
    - (Buscamos información sensible como numeros de tarjeta, contraseñas, usuarios, tokens, etc)
   
## Insecure Data Storage:
  - En ocasiones las aplicaciones guardan sin cifrar o en archivos inseguros las contraseñas o accesos en los archivos del telefono, por ejemplo el usuario y contraseña para no tener que ingresarla de 0.
    - adb shell
    - root> ls -l /data/data
    - root> cd /data/data/<carpetadeapk>
    - CASO 1:
      - root> strings *.config (buscar contraseñas o accesos en texto plano como ficheros config, temporales, xml, etc.)
    - CASO 2:
      - root> strings *.db (buscar contraseñas o accesos en logs de ejecución de SQL)
    - CASO 3:
      - root> cd /storage/emulated/0/
      - root> strings *.txt (ficheros legibles guardados dentro de las carpetas de downloads, documents, etc)
   
## Hardcoding:
  - Asignación de variables estaticas a información sensible como claves, usuarios, tokens, etc.
    - Lectura del fichero class con java decompiler, buscando codigo como:
      - ...findmyview(12313).getText().toString().equals("secretpassword123")
     
## Input validation:
  - Al igual que una pagina web, aquí sino se valida el codigo que se ingresa del lado del "servidor" que puede ser la API o la propia ejecución de la APK, puede ser ejecutado codigo malicioso.
    - SQLI:
      - Buscar codigo SQL embebido en la aplicación de SQL Lite vulnerable a ser inyectable.
        - SQLI ERROR: ' or 1=1-- (Por ejemplo para una ejecución de sql donde se imprima el valor dentro de una tabla)
    - WEBView:
      - Funciones embebidas en las funciones de android que permiten ver ficheros, paginas web, etc, que sí no son sanitizadas podemos modificarlas y usarlas para hacer metodos para los que no está definida una función.
        - Sí encontramos un campo que permite abrir una pagina web ingresada por el usuario, podemos ingresar:
          - file:///data/data/ficherossecret.txt
















