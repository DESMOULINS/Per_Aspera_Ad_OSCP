# Introducción:
Pentesting mobile principalmente se basa en analisis de codigo estatico y dinamico de una APK para android e IPA para IOS.

# Framework base:
OWASP así como para web, tambien para mobile tiene su versión de testing guide, las cuales son muy amplias y son una base solida para un correcto proceso.
  - https://mas.owasp.org/#our-mission
  - https://owasp.org/www-project-mobile-top-10/2023-risks/

# Virtualizadores:
  - Genymotion: Virtualizador basado en virtualbox, con versión personal gratuita, pero con limitaciones como no permitir rootear.

# Estructura basica:

## Android APK:
Estructura de ficheros y carpetas de una aplicación:
- /META-INF:
  - Manifest: Creador, fechas, etc
- /res: Ficheros que no se compilan en resources.arsc
  - /layout: Pantallas de la aplicación
  - /drawable: Imagenes que se usan en la aplicación
- /assets: Ficheros opcionales llamados por el AssetManager
- /lib: Codigo compilado, como librerias nativas
- AndriodManifest.xml: Lista de permisos y funciones de la aplicación
- resources.arsc: Recursos precomplilados en XML
- Classes.dex: Se comporta similar a una java VM, pero basadas en davlkin (android < 5.0 ) o ART (android > 5.0)
    - DEX = (D)avlkin (EX)ecutable
    - Arquitectura de DAVLKIN:
        - .DEX son las que estan en la playstore
        - .ODEX son versiones optimizadas para correr en boot-time y creadas para dispositivos especificos, y solo usada por OEMs (samnsung, xiaomi, etc.) por ejemplo la aplicación de telefono, configuración, etc.
            - NOTA: Hoy en dia no es tan comun su uso con la llegada de ART, dado que ART hace que su optimización ya no sea tan necesaria por su mejora en ejecución, ademas que ART convierte los ficheros .dex a .aot (codigo nativo) y los coloca en carpetas protegidas.
    - Arquitectura de ART:
        - .AOT:
            - Es el fichero principalmente usado, es el resultante de compilar el fichero .dex a codigo nativo
            - Se puede decir que es el "equivalente" a los ficheros .elf de linux, pero a partir de android 7 se volvieron más complejos y con su propia estructura.
        - .VDEX: Contiene
            - .dex originales (para correr como una Dalvkin VM en casos de fallo en la compilación)
            - metadata
            - información para validación.

## OS Android:
- Jerarquia:
    - 1 - Applications: Aplicaciones visibles al usuario que utilizan el framework para funcionar.
        - Home, contacts, browser.
    - 2 - Application framework: Conjunto de APIs que permite a las apps interactuar con el sistema y entre sí.
        - Activity manager, Window manager, Contact provider, packet manager, etc.
    - 3 - Libreries: Librerías C/C++ usadas por el framework y las apps para funciones gráficas, base de datos, multimedia, etc.
        - Surface manager, Media framework, SQLite, OpenGL, freetype.
    - 3 - Android runtime: Motor de ejecución para apps Android; incluye las bibliotecas básicas de Java y la máquina virtual.
        - Core libreries, dalvik/ART virtual machine.
    - Linux kernel: Núcleo del sistema operativo, se encarga del manejo del hardware y la seguridad.
        - Display server, camera driver, flash memory driver, WIFI Driver, etc.
     
- Seguridad:
    - 1 - Aislamiento:
        - Cada aplicación tiene su propio entorno separado por User ID, similar a linux, asignado dinamicamente con cada instalalación, cada aplicación solo debe tener permitido interactuar con ficheros con el mismo ID que el suyo, a expecto sean ficheros compartidos por otra aplicación o el sistema operativo.
        -  Sí ejecutas ls -na veras que cada usuario tiene un ID y group ID similar a linux
            -  drwxr-x--x 10000 10000 <timestamp> com.android.backup
            -  drwxr-x--x 10011 10011 <timestamp> com.android.backuptester
        -  Existen grupos especiales, por ejemplo sdcard_rw, que cuando una app se agrega este grupo, tiene permiso de lectura y escritura desde la base del sdcard.
        -  Para ver el UserID asignado ejecuta # dumpsys package | grep 'Package \[' -A1
        -  En versiones menores a la 5, sí se comprometia el usuario root, no habia otro "aislamiento" a las apps.
        -  En versiones mayores o igual a la 5, se implementa SELinux, permitiendo solo interacciones "seguras" ademas de las clasicas de UID.

# Desarrollo:
## Android:
- Java o Kotlin (Busca reemplazar a java)

### Proceso de desarrollo:
- Codigo base: Java o kotlin
- Compilado: .class -> Javac tool -> dex
    - En los ficheros antiguos de dalvik se usaban registros "variables temporales" que guardan datos durante la ejecución de la apk, ex. v0, v1, etc.
    - Cada registro guarda hasta 32 bits, variables tipo int, float, boolean, etc, pero en casos como long o double se usan dos registros seguidos.
- Conversión: .dex -> dx o d8 -> .apk
- Firmado: apk -> firma -> apk
- Distribución: apk -> google play -> app

## iOS:
- Objective C or swift

## Hybrid:
- HTML, JS and CSS sing frameworks like PhoneGap, Ionic and among.

# Decompilación y lectura:
## Android:
- Proceso logico:
    - Decompilado: .apk -> apktool d (tool) -> /smali (codigo decompilado del classes.dex)
    - Conversión a jar: .apk -> unzip (tool) -> classes.dex (bytecode Dalvik o ART) -> j2d-dex2jar -> classes.jar -> jd-gui (tool) -> codigo legible

- Herramientas:
  - Decompilado a smali:
    - apktool d <nameapk>.apk
  - Reversing a codigo fuente:
    - unzip <nameapk>.apk
    - j2d-dex2jar classes.dex
    - Open with jd-gui file classes.jar

# Ataques comunes:
Lista de comandos para revisión de vulnerabilidades comunes en base a DIVA APK.

## Insecure Logging:
  - Siempre es buena opción ir guardando los Logs salientes de la aplicación mientras navegamos, porque podemos buscar datos sensibles que se esten guardando como Logs.
    - adb shell ps | grep <appname> (Conseguir el numero del proceso)
    - adb logcat | grep <processnumber> (Imprimira todo lo que este pasado por un proceso de log)
    - (Buscamos información sensible como numeros de tarjeta, contraseñas, usuarios, tokens, etc)

## Insecure Data Storage:
  - En ocasiones las aplicaciones guardan sin cifrar o en archivos inseguros las contraseñas o accesos en los archivos del telefono, por ejemplo el usuario y contraseña para no tener que ingresarla de 0.
    - adb shell
    - root> ls -l /data/data
    - root> cd /data/data/<carpetadeapk>
    - CASO 1:
      - root> strings *.config (buscar contraseñas o accesos en texto plano como ficheros config, temporales, xml, etc.)
    - CASO 2:
      - root> strings *.db (buscar contraseñas o accesos en logs de ejecución de SQL)
    - CASO 3:
      - root> cd /storage/emulated/0/
      - root> strings *.txt (ficheros legibles guardados dentro de las carpetas de downloads, documents, etc)
   
## Hardcoding:
  - Asignación de variables estaticas a información sensible como claves, usuarios, tokens, etc.
    - Lectura del fichero class con java decompiler, buscando codigo como:
      - ...findmyview(12313).getText().toString().equals("secretpassword123")
     
## Input validation:
  - Al igual que una pagina web, aquí sino se valida el codigo que se ingresa del lado del "servidor" que puede ser la API o la propia ejecución de la APK, puede ser ejecutado codigo malicioso.
    - SQLI:
      - Buscar codigo SQL embebido en la aplicación de SQL Lite vulnerable a ser inyectable.
        - SQLI ERROR: ' or 1=1-- (Por ejemplo para una ejecución de sql donde se imprima el valor dentro de una tabla)
    - WEBView:
      - Funciones embebidas en las funciones de android que permiten ver ficheros, paginas web, etc, que sí no son sanitizadas podemos modificarlas y usarlas para hacer metodos para los que no está definida una función.
        - Sí encontramos un campo que permite abrir una pagina web ingresada por el usuario, podemos ingresar:
          - file:///data/data/ficherossecret.txt
















