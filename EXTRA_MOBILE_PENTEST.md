# Introducción:
Pentesting mobile principalmente se basa en analisis de codigo estatico y dinamico de una APK para android e IPA para IOS.

# Framework base:
OWASP así como para web, tambien para mobile tiene su versión de testing guide, las cuales son muy amplias y son una base solida para un correcto proceso.
  - https://mas.owasp.org/#our-mission
  - https://owasp.org/www-project-mobile-top-10/2023-risks/

# Virtualizadores:
  - Genymotion: Virtualizador basado en virtualbox, con versión personal gratuita, pero con limitaciones como no permitir rootear.
    - Procedimiento basico para configurar:
      - Instalar genymotion
      - Instalar android 11 con custom phone
      - Instalar playstore en el android
      - Abrir el proxy de burpsuite a cualquier interfaz
      - Descargar cert de burpsuite en kali y convertir el fichero:
        - > openssl x509 -inform DER -in burp.der -out cacert.pem
        - > openssl x509 -inform PEM -subject_hash_old -in cacert.pem
        - > mv cacert.pem 9a5ba575.0 (el hash puede cambiar es basado en el comando anterior)
      - Instalar abd en kali
        - > abd connect 192.0.0.1:5555
        - > adb remount
        - > adb shell
        - > adb push 9a5ba575.0 /system/etc/security/cacerts/
      - Valida que el cert este dentro de los certificados de sistema

# Estructura basica:

## Android APK:
Estructura de ficheros y carpetas de una aplicación:
- /META-INF:
  - Manifest:
    - Creador, fechas, etc.
    - List all Files and their SHA1
  - cert.rsa:
    - Developer´s signing certificate
    - En estas arquitecturas no se usan CA.
  - Cert.sf:
    - List of resources and their hashes
- /res: Ficheros que no se compilan en resources.arsc
  - /layout: Pantallas de la aplicación
  - /drawable: Imagenes que se usan en la aplicación
- /assets: Ficheros opcionales llamados por el AssetManager
- /lib: Codigo compilado, como librerias nativas
- AndriodManifest.xml: Lista de permisos y funciones de la aplicación
- resources.arsc: Recursos precomplilados en XML
- Classes.dex: Se comporta similar a una java VM, pero basadas en davlkin (android < 5.0 ) o ART (android > 5.0)
    - DEX = (D)avlkin (EX)ecutable
    - Arquitectura de DAVLKIN:
        - .DEX son las que estan en la playstore
        - .ODEX son versiones optimizadas para correr en boot-time y creadas para dispositivos especificos, y solo usada por OEMs (samnsung, xiaomi, etc.) por ejemplo la aplicación de telefono, configuración, etc.
            - NOTA: Hoy en dia no es tan comun su uso con la llegada de ART, dado que ART hace que su optimización ya no sea tan necesaria por su mejora en ejecución, ademas que ART convierte los ficheros .dex a .aot (codigo nativo) y los coloca en carpetas protegidas.
    - Arquitectura de ART:
        - .AOT:
            - Es el fichero principalmente usado, es el resultante de compilar el fichero .dex a codigo nativo.
            - Se puede decir que es el "equivalente" a los ficheros .elf de linux, pero a partir de android 7 se volvieron más complejos y con su propia estructura.
        - .VDEX: Contiene
            - .dex originales (para correr como una Dalvkin VM en casos de fallo en la compilación)
            - metadata
            - información para validación.

## OS Android:
- Jerarquia:
    - 1 - Applications: Aplicaciones visibles al usuario que utilizan el framework para funcionar.
        - Home, contacts, browser.
    - 2 - Application framework: Conjunto de APIs que permite a las apps interactuar con el sistema y entre sí.
        - Activity manager, Window manager, Contact provider, packet manager, etc.
    - 3 - Libreries: Librerías C/C++ usadas por el framework y las apps para funciones gráficas, base de datos, multimedia, etc.
        - Surface manager, Media framework, SQLite, OpenGL, freetype.
    - 3 - Android runtime: Motor de ejecución para apps Android; incluye las bibliotecas básicas de Java y la máquina virtual.
        - Core libreries, dalvik/ART virtual machine.
    - Linux kernel: Núcleo del sistema operativo, se encarga del manejo del hardware y la seguridad.
        - Display server, camera driver, flash memory driver, WIFI Driver, etc.
     
- Seguridad:
    - 1 - Aislamiento:
        - Cada aplicación tiene su propio entorno separado por User ID, similar a linux, asignado dinamicamente con cada instalalación, cada aplicación solo debe tener permitido interactuar con ficheros con el mismo ID que el suyo, a expecto sean ficheros compartidos por otra aplicación o el sistema operativo.
        -  Sí ejecutas ls -na veras que cada usuario tiene un ID y group ID similar a linux
            -  drwxr-x--x 10000 10000 <timestamp> com.android.backup
            -  drwxr-x--x 10011 10011 <timestamp> com.android.backuptester
        -  Existen grupos especiales, por ejemplo sdcard_rw, que cuando una app se agrega este grupo, tiene permiso de lectura y escritura desde la base del sdcard.
        -  Para ver el UserID asignado ejecuta # dumpsys package | grep 'Package \[' -A1
        -  En versiones menores a la 5, sí se comprometia el usuario root, no habia otro "aislamiento" a las apps.
        -  En versiones mayores o igual a la 5, se implementa SELinux, permitiendo solo interacciones "seguras" ademas de las clasicas de UID.

# Desarrollo:
## Android:
- Java o Kotlin (Busca reemplazar a java)

### Proceso de desarrollo:
- Proceso general:
  - Codigo base: Java o kotlin
  - Compilado: .class -> Javac tool -> dex
      - En los ficheros antiguos de dalvik se usaban registros "variables temporales" que guardan datos durante la ejecución de la apk, ex. v0, v1, etc.
      - Cada registro guarda hasta 32 bits, variables tipo int, float, boolean, etc, pero en casos como long o double se usan dos registros seguidos.
  - Conversión: .dex -> dx o d8 -> .apk
  - Firmado: apk -> firma -> apk
  - Distribución: apk -> google play -> app

### Seguridad en codigo:
Herramientas que ofuscan el codigo como proguard y R8 dan protección basica contra analisis estatico, pero dexguard o app shilding dan una protección contra analisis dinamico al tener protección durante la ejecución.

- Proguard:
  - Herramienta usada en desarrollo usada para:
    - Reducir el tamaño de la apk eliminando clases, metodos y atributos no usados.
    - Ofuscar el codigo reemplazando nombres de clases, metodos y variables por genericos como "a", "b", etc.
- R8:
  - Sustituto de proguard en androidstudio.
- Dexguard:  
  - Versión de paga de proguard, con ventajas como:
    - Ofuscación avanzada
    - Cifrado de strings
- App Shielding (e.g., Guardsquare Shield, Arxan, Promon)
  - Protección durante ejecución contra hooking
  - Detección de rooteo o emulador.

## iOS:
- Objective C or swift

## Hybrid:
- HTML, JS and CSS sing frameworks like PhoneGap, Ionic and among.

# Decompilación y lectura:
## Android:
- Proceso logico:
    - Decompilado: .apk -> apktool d (tool) -> /smali (codigo "ensamblador" obtenido del binario classes.dex)
    - Conversión a jar: .apk -> unzip (tool) -> classes.dex (bytecode Dalvik o ART) -> j2d-dex2jar -> classes.jar -> jd-gui (tool) -> codigo legible

- Herramientas:
  - Decompilado a smali:
    - apktool d <nameapk>.apk
  - Reversing a codigo fuente:
    - unzip <nameapk>.apk
    - d2j-dex2jar classes.dex
    - Open with jd-gui file classes.jar

# Ataques comunes:
Lista de comandos para revisión de vulnerabilidades comunes en base a DIVA APK.

## Insecure Logging:
  - Siempre es buena opción ir guardando los Logs salientes de la aplicación mientras navegamos, porque podemos buscar datos sensibles que se esten guardando como Logs.
    - adb shell ps | grep <appname> (Conseguir el numero del proceso)
    - adb logcat | grep <processnumber> (Imprimira todo lo que este pasado por un proceso de log)
    - (Buscamos información sensible como numeros de tarjeta, contraseñas, usuarios, tokens, etc)

## Insecure Data Storage:
  - En ocasiones las aplicaciones guardan sin cifrar o en archivos inseguros las contraseñas o accesos en los archivos del telefono, por ejemplo el usuario y contraseña para no tener que ingresarla de 0.
    - adb shell
    - root> ls -l /data/data
    - root> cd /data/data/<carpetadeapk>
    - CASO 1: Ficheros de configuración.
      - root> strings *.config (buscar contraseñas o accesos en texto plano como ficheros config, temporales, xml, etc.)
    - CASO 2: Ficheros de SQL.
      - root> strings *.db (buscar contraseñas o accesos en logs de ejecución de SQL)
    - CASO 3: Ficheros escritos por la app.
      - root> cd /storage/emulated/0/
      - root> strings *.txt (ficheros legibles guardados dentro de las carpetas de downloads, documents, etc)
    - CASO 4: Cadenas almacenadas en /res/values:
      - Carpeta creada durante el desarrollo que en el compilado se envia a resources.arsc
      - Para leerlo debemos usar apktool y buscar la carpeta de values, ejemplo strings.xml
        - Nota: el fichero de R.classs es el "indice" de estos valores, que mapea hacia /res/values y sus cadenas

## Hardcoding:
  - Asignación de variables estaticas a información sensible como claves, usuarios, tokens, etc.
    - Lectura del fichero class con java decompiler, buscando codigo como:
      - ...findmyview(12313).getText().toString().equals("secretpassword123")
     
## Input validation:
  - Al igual que una pagina web, aquí sino se valida el codigo que se ingresa del lado del "servidor" que puede ser la API o la propia ejecución de la APK, puede ser ejecutado codigo malicioso.
    - SQLI:
      - Buscar codigo SQL embebido en la aplicación de SQL Lite vulnerable a ser inyectable.
        - SQLI ERROR: ' or 1=1-- (Por ejemplo para una ejecución de sql donde se imprima el valor dentro de una tabla)
    - WEBView:
      - Funciones embebidas en las funciones de android que permiten ver ficheros, paginas web, etc, que sí no son sanitizadas podemos modificarlas y usarlas para hacer metodos para los que no está definida una función.
        - Sí encontramos un campo que permite abrir una pagina web ingresada por el usuario, podemos ingresar:
          - file:///data/data/ficherossecret.txt
















